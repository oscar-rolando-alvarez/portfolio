import * as anchor from "@project-serum/anchor";
import { Program } from "@project-serum/anchor";
import { PublicKey, Keypair, SystemProgram, LAMPORTS_PER_SOL } from "@solana/web3.js";
import { TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID, createMint, createAccount, mintTo } from "@solana/spl-token";
import { expect } from "chai";
import { Marketplace } from "../target/types/marketplace";

describe("NFT Marketplace", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.Marketplace as Program<Marketplace>;
  const admin = Keypair.generate();\n  const seller = Keypair.generate();\n  const buyer = Keypair.generate();\n  const treasury = Keypair.generate();\n  \n  let marketplacePda: PublicKey;\n  let nftMint: PublicKey;\n  let listingPda: PublicKey;\n  \n  before(async () => {\n    // Airdrop SOL to test accounts\n    await provider.connection.confirmTransaction(\n      await provider.connection.requestAirdrop(admin.publicKey, 2 * LAMPORTS_PER_SOL)\n    );\n    await provider.connection.confirmTransaction(\n      await provider.connection.requestAirdrop(seller.publicKey, 2 * LAMPORTS_PER_SOL)\n    );\n    await provider.connection.confirmTransaction(\n      await provider.connection.requestAirdrop(buyer.publicKey, 2 * LAMPORTS_PER_SOL)\n    );\n    \n    // Find PDAs\n    [marketplacePda] = PublicKey.findProgramAddressSync(\n      [Buffer.from(\"marketplace\")],\n      program.programId\n    );\n    \n    // Create NFT mint\n    nftMint = await createMint(\n      provider.connection,\n      seller,\n      seller.publicKey,\n      seller.publicKey,\n      0\n    );\n  });\n  \n  it(\"Initializes the marketplace\", async () => {\n    const marketplaceFee = 250; // 2.5%\n    const maxListingDuration = 30 * 24 * 60 * 60; // 30 days\n    \n    const tx = await program.methods\n      .initializeMarketplace(marketplaceFee, maxListingDuration)\n      .accounts({\n        marketplace: marketplacePda,\n        admin: admin.publicKey,\n        treasury: treasury.publicKey,\n        systemProgram: SystemProgram.programId,\n      })\n      .signers([admin])\n      .rpc();\n    \n    const marketplaceAccount = await program.account.marketplace.fetch(marketplacePda);\n    \n    expect(marketplaceAccount.admin.toString()).to.equal(admin.publicKey.toString());\n    expect(marketplaceAccount.marketplaceFee).to.equal(marketplaceFee);\n    expect(marketplaceAccount.maxListingDuration.toNumber()).to.equal(maxListingDuration);\n    expect(marketplaceAccount.isPaused).to.be.false;\n  });\n  \n  it(\"Lists an NFT for sale\", async () => {\n    const price = 1.5 * LAMPORTS_PER_SOL;\n    const expiry = Math.floor(Date.now() / 1000) + 7 * 24 * 60 * 60; // 7 days\n    \n    // Create seller's NFT token account and mint NFT\n    const sellerNftAccount = await createAccount(\n      provider.connection,\n      seller,\n      nftMint,\n      seller.publicKey\n    );\n    \n    await mintTo(\n      provider.connection,\n      seller,\n      nftMint,\n      sellerNftAccount,\n      seller,\n      1\n    );\n    \n    // Find listing PDA\n    [listingPda] = PublicKey.findProgramAddressSync(\n      [Buffer.from(\"listing\"), nftMint.toBuffer(), seller.publicKey.toBuffer()],\n      program.programId\n    );\n    \n    // Find listing NFT account PDA\n    const [listingNftAccount] = PublicKey.findProgramAddressSync(\n      [Buffer.from(\"listing_nft\"), listingPda.toBuffer()],\n      program.programId\n    );\n    \n    // Mock metadata account (in real test, this would be created properly)\n    const [metadataPda] = PublicKey.findProgramAddressSync(\n      [Buffer.from(\"metadata\"), new PublicKey(\"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\").toBuffer(), nftMint.toBuffer()],\n      new PublicKey(\"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\")\n    );\n    \n    const tx = await program.methods\n      .listNft(new anchor.BN(price), new anchor.BN(expiry), true)\n      .accounts({\n        marketplace: marketplacePda,\n        listing: listingPda,\n        seller: seller.publicKey,\n        nftMint: nftMint,\n        sellerNftAccount: sellerNftAccount,\n        listingNftAccount: listingNftAccount,\n        metadata: metadataPda,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,\n        systemProgram: SystemProgram.programId,\n      })\n      .signers([seller])\n      .rpc();\n    \n    const listingAccount = await program.account.listing.fetch(listingPda);\n    \n    expect(listingAccount.seller.toString()).to.equal(seller.publicKey.toString());\n    expect(listingAccount.nftMint.toString()).to.equal(nftMint.toString());\n    expect(listingAccount.price.toNumber()).to.equal(price);\n    expect(listingAccount.allowOffers).to.be.true;\n  });\n  \n  it(\"Purchases a listed NFT\", async () => {\n    // Create buyer's NFT token account\n    const buyerNftAccount = await createAccount(\n      provider.connection,\n      buyer,\n      nftMint,\n      buyer.publicKey\n    );\n    \n    const [listingNftAccount] = PublicKey.findProgramAddressSync(\n      [Buffer.from(\"listing_nft\"), listingPda.toBuffer()],\n      program.programId\n    );\n    \n    const initialBuyerBalance = await provider.connection.getBalance(buyer.publicKey);\n    const initialSellerBalance = await provider.connection.getBalance(seller.publicKey);\n    \n    const tx = await program.methods\n      .purchaseNft()\n      .accounts({\n        marketplace: marketplacePda,\n        listing: listingPda,\n        buyer: buyer.publicKey,\n        seller: seller.publicKey,\n        listingNftAccount: listingNftAccount,\n        buyerNftAccount: buyerNftAccount,\n        treasury: treasury.publicKey,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,\n        systemProgram: SystemProgram.programId,\n      })\n      .signers([buyer])\n      .rpc();\n    \n    const finalBuyerBalance = await provider.connection.getBalance(buyer.publicKey);\n    const finalSellerBalance = await provider.connection.getBalance(seller.publicKey);\n    \n    // Check that buyer paid and seller received (minus fees)\n    expect(initialBuyerBalance - finalBuyerBalance).to.be.greaterThan(1.4 * LAMPORTS_PER_SOL);\n    expect(finalSellerBalance - initialSellerBalance).to.be.greaterThan(1.4 * LAMPORTS_PER_SOL);\n    \n    // Check that listing is marked as sold\n    const listingAccount = await program.account.listing.fetch(listingPda);\n    expect(listingAccount.status).to.deep.equal({ sold: {} });\n  });\n  \n  it(\"Prevents unauthorized marketplace config updates\", async () => {\n    const unauthorizedUser = Keypair.generate();\n    \n    try {\n      await program.methods\n        .updateMarketplaceConfig(300, null, null)\n        .accounts({\n          marketplace: marketplacePda,\n          admin: unauthorizedUser.publicKey,\n        })\n        .signers([unauthorizedUser])\n        .rpc();\n      \n      expect.fail(\"Should have thrown an error\");\n    } catch (error) {\n      expect(error.message).to.include(\"NotAdmin\");\n    }\n  });\n  \n  it(\"Allows admin to pause marketplace\", async () => {\n    await program.methods\n      .pauseMarketplace()\n      .accounts({\n        marketplace: marketplacePda,\n        admin: admin.publicKey,\n      })\n      .signers([admin])\n      .rpc();\n    \n    const marketplaceAccount = await program.account.marketplace.fetch(marketplacePda);\n    expect(marketplaceAccount.isPaused).to.be.true;\n  });\n});"